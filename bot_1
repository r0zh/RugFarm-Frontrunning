import os
import base64
import time
from dotenv import load_dotenv
from solana.rpc.api import Client
from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.instruction import Instruction
from solders.transaction import Transaction
from solders.system_program import transfer, TransferParams
from solders.message import Message
from solana.rpc.commitment import Confirmed
import threading
from solana.rpc.types import TxOpts
import requests

# Cargar variables de entorno
load_dotenv()

# Variables de entorno
PRIVATE_KEY = os.getenv('PRIVATE_KEY')
PUBLIC_KEY = os.getenv('PUBLIC_KEY')
RPC_URL = f"https://devnet.helius-rpc.com/?api-key={os.getenv('HELIUS_API_KEY')}"
TOKEN_ADDRESS = "GvmTPPD7M38kpkncdEr3K25fk64TDYWHuLjKU2WXVoci"  # Se define mÃ¡s adelante
RIESGO_USDT = 10  # Monto en USDT definido por el usuario
CONDICION_SALIDA = True  # Activar la condiciÃ³n de salida
UMBRAL_SALIDA = 1.01  # Salir cuando el valor del token aumente un 1%
UMBRAL_BAJA = 0.96  # Salir si el valor del token disminuye un 4%
STOP_MANUAL = False  # Variable para detener manualmente el bot

# Validar claves
if not PRIVATE_KEY:
    raise ValueError("âŒ PRIVATE_KEY no estÃ¡ definida en el archivo .env")
if not PUBLIC_KEY:
    raise ValueError("âŒ PUBLIC_KEY no estÃ¡ definida en el archivo .env")
if not RPC_URL or 'api-key=' not in RPC_URL:
    raise ValueError("âŒ HELIUS_API_KEY no estÃ¡ definida correctamente en el archivo .env")

# Inicializar cliente RPC con Helius en Devnet
try:
    client = Client(RPC_URL)
    print("âœ… Cliente RPC de Helius (Devnet) conectado correctamente.")
except Exception as e:
    print(f"âŒ Error al conectar con RPC de Helius (Devnet): {e}")
    exit()

# Inicializar billetera
try:
    if PRIVATE_KEY:
        keypair = Keypair.from_bytes(base64.b64decode(PRIVATE_KEY))
        public_key = PublicKey.from_string(PUBLIC_KEY)
        print(f"âœ… Wallet conectada: {public_key}")
    else:
        raise ValueError("PRIVATE_KEY no encontrada en el archivo .env")
except Exception as e:
    print(f"âŒ Error al cargar la clave privada: {e}")
    exit()

# Obtener el precio actual de Solana (usando un proveedor de datos externo)
def obtener_precio_solana():
    try:
        import requests
        response = requests.get('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd')
        data = response.json()
        return data['solana']['usd']
    except Exception as e:
        print(f"âŒ Error al obtener el precio de Solana: {e}")
        return None

# Calcular el riesgo en SOL
def calcular_riesgo_sol(riesgo_usdt, precio_solana):
    if precio_solana:
        riesgo_sol = riesgo_usdt / precio_solana
        print(f"ðŸ’µ Riesgo definido: {riesgo_usdt} USDT â‰ˆ {riesgo_sol:.4f} SOL")
        return riesgo_sol
    else:
        print("âŒ No se pudo calcular el riesgo en SOL debido a un error en el precio de Solana.")
        return None

# Calcular el riesgo porcentual respecto al balance
def calcular_riesgo_porcentual(balance, riesgo_sol):
    if balance > 0:
        riesgo_porcentual = (riesgo_sol / balance) * 100
        print(f"ðŸ“Š Riesgo porcentual: {riesgo_porcentual:.2f}% del balance total.")
        return riesgo_porcentual
    else:
        print("âŒ Balance insuficiente para calcular riesgo porcentual.")
        return None

# Obtener el balance de la cuenta
def obtener_balance(public_key):
    try:
        balance_response = client.get_balance(public_key)
        balance = balance_response.value / 1e9  # Convertir de lamports a SOL
        print(f"ðŸ’° Balance actual en Devnet: {balance:.4f} SOL")
        return balance
    except Exception as e:
        print(f"âŒ Error al obtener el balance: {e}")
        return None

# Obtener el bloque reciente
def obtener_recent_blockhash():
    try:
        recent_blockhash = client.get_latest_blockhash(Confirmed).value.blockhash
        return recent_blockhash
    except Exception as e:
        print(f"âŒ Error al obtener el blockhash reciente: {e}")
        return None


# ðŸ” FunciÃ³n para obtener la billetera del vendedor
def obtener_seller_wallet(token_address):
    """
    Encuentra automÃ¡ticamente la billetera para comprar un token dado su address.
    """
    try:
        # Consultar API de Helius
        url = f"https://api.helius.xyz/v0/token-metadata?api-key={os.getenv('HELIUS_API_KEY')}&id={token_address}"
        response = requests.get(url)
        
        if response.status_code == 200:
            data = response.json()
            seller_wallet = data.get('mint', {}).get('authority')
            
            if seller_wallet:
                print(f"âœ… SELLER_WALLET detectado automÃ¡ticamente: {seller_wallet}")
                return seller_wallet
            else:
                print("âŒ No se encontrÃ³ la 'authority' en los metadatos del token.")
                return None
        else:
            print(f"âŒ Error en la API (CÃ³digo {response.status_code})")
            return None
    except Exception as e:
        print(f"âŒ Error al obtener SELLER_WALLET: {e}")
        return None
    
# ðŸ›’ Comprar Tokens AutomÃ¡ticamente
def comprar_token(cantidad_sol, seller_wallet):
    """
    Realiza una compra enviando SOL a la billetera del vendedor.
    """
    try:
        seller_public_key = PublicKey(seller_wallet)
        
        tx = Transaction()
        tx.add(
            transfer(
                TransferParams(
                    from_pubkey=keypair.public_key,
                    to_pubkey=seller_public_key,
                    lamports=int(cantidad_sol * 10**9)  # Convertir SOL a lamports
                )
            )
        )
        
        # Enviar la transacciÃ³n
        response = client.send_transaction(
            tx, keypair, opts=TxOpts(skip_preflight=True)
        )
        print(f"âœ… TransacciÃ³n enviada: {response['result']}")
        return response['result']
    
    except Exception as e:
        print(f"âŒ Error al comprar token: {e}")
        return None


    
# Hilo para el botÃ³n de stop manual
def stop_bot():
    global STOP_MANUAL
    input("ðŸ›‘ Presiona Enter para detener el bot manualmente...")
    STOP_MANUAL = True

# FunciÃ³n principal del bot
def main():
    global STOP_MANUAL
    
    # 1ï¸âƒ£ Obtener el precio actual de Solana
    precio_solana = obtener_precio_solana()
    if not precio_solana:
        print("âŒ No se pudo obtener el precio de Solana. Saliendo...")
        return

    # 2ï¸âƒ£ Obtener el balance de la billetera
    balance = obtener_balance(public_key)
    if balance is None:
        return

    # 3ï¸âƒ£ Calcular el riesgo en SOL
    riesgo_sol = calcular_riesgo_sol(RIESGO_USDT, precio_solana)
    if riesgo_sol is None:
        return

    calcular_riesgo_porcentual(balance, riesgo_sol)

    # 4ï¸âƒ£ Detectar automÃ¡ticamente el SELLER_WALLET
    seller_wallet = obtener_seller_wallet(TOKEN_ADDRESS)
    if not seller_wallet:
        print("âŒ No se pudo detectar SELLER_WALLET. Verifica la direcciÃ³n del token.")
        return

    print(f"âœ… SELLER_WALLET detectado: {seller_wallet}")

    # 5ï¸âƒ£ Realizar la compra del token
    precio_compra = comprar_token(riesgo_sol, seller_wallet)
    if precio_compra:
        print(f"âœ… Compra realizada. Precio de compra: {precio_compra}")
        
        # 6ï¸âƒ£ Monitorear la condiciÃ³n de salida
        while CONDICION_SALIDA and not STOP_MANUAL:
            precio_actual = obtener_precio_solana()
            if precio_actual:
                if precio_actual >= precio_compra * UMBRAL_SALIDA:
                    print(f"âœ… CondiciÃ³n de salida cumplida (Subida): Precio actual {precio_actual:.2f} USD")
                    break
                if precio_actual <= precio_compra * UMBRAL_BAJA:
                    print(f"âœ… CondiciÃ³n de salida cumplida (Bajada): Precio actual {precio_actual:.2f} USD")
                    break
            time.sleep(10)
    else:
        print("âŒ La compra no se pudo completar. Revisa los logs anteriores.")
    
    print("âœ… Bot detenido.")


if __name__ == '__main__':
    threading.Thread(target=stop_bot).start()
    main()