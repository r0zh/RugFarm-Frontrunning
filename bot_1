import os
import base64
import time
from dotenv import load_dotenv
from solana.rpc.api import Client
from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.transaction import Transaction
from solders.system_program import transfer, TransferParams
from solana.rpc.commitment import Confirmed

# Cargar variables de entorno
load_dotenv()

# Variables de entorno
PRIVATE_KEY = os.getenv('PRIVATE_KEY')
PUBLIC_KEY = os.getenv('PUBLIC_KEY')
RPC_URL = f"https://devnet.helius-rpc.com/?api-key={os.getenv('HELIUS_API_KEY')}"
TOKEN_ADDRESS = "nombre_token"  # Se define m√°s adelante
RIESGO_USDT = 100  # Monto en USDT definido por el usuario
CONDICION_SALIDA = False  # Condici√≥n de salida (por definir)

# Validar claves
if not PRIVATE_KEY:
    raise ValueError("‚ùå PRIVATE_KEY no est√° definida en el archivo .env")
if not PUBLIC_KEY:
    raise ValueError("‚ùå PUBLIC_KEY no est√° definida en el archivo .env")
if not RPC_URL or 'api-key=' not in RPC_URL:
    raise ValueError("‚ùå HELIUS_API_KEY no est√° definida correctamente en el archivo .env")

# Inicializar cliente RPC con Helius en Devnet
try:
    client = Client(RPC_URL)
    print("‚úÖ Cliente RPC de Helius (Devnet) conectado correctamente.")
except Exception as e:
    print(f"‚ùå Error al conectar con RPC de Helius (Devnet): {e}")
    exit()

# Inicializar billetera
try:
    if PRIVATE_KEY:
        keypair = Keypair.from_bytes(base64.b64decode(PRIVATE_KEY))
        public_key = PublicKey.from_string(PUBLIC_KEY)
        print(f"‚úÖ Wallet conectada: {public_key}")
    else:
        raise ValueError("PRIVATE_KEY no encontrada en el archivo .env")
except Exception as e:
    print(f"‚ùå Error al cargar la clave privada: {e}")
    exit()

# Obtener el precio actual de Solana (usando un proveedor de datos externo)
def obtener_precio_solana():
    try:
        import requests
        response = requests.get('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd')
        data = response.json()
        return data['solana']['usd']
    except Exception as e:
        print(f"‚ùå Error al obtener el precio de Solana: {e}")
        return None

# Calcular el riesgo en SOL
def calcular_riesgo_sol(riesgo_usdt, precio_solana):
    if precio_solana:
        riesgo_sol = riesgo_usdt / precio_solana
        print(f"üíµ Riesgo definido: {riesgo_usdt} USDT ‚âà {riesgo_sol:.4f} SOL")
        return riesgo_sol
    else:
        print("‚ùå No se pudo calcular el riesgo en SOL debido a un error en el precio de Solana.")
        return None

# Calcular el riesgo porcentual respecto al balance
def calcular_riesgo_porcentual(balance, riesgo_sol):
    if balance > 0:
        riesgo_porcentual = (riesgo_sol / balance) * 100
        print(f"üìä Riesgo porcentual: {riesgo_porcentual:.2f}% del balance total.")
        return riesgo_porcentual
    else:
        print("‚ùå Balance insuficiente para calcular riesgo porcentual.")
        return None

# Obtener el balance de la cuenta
def obtener_balance(public_key):
    try:
        balance_response = client.get_balance(public_key)
        balance = balance_response.value / 1e9  # Convertir de lamports a SOL
        print(f"üí∞ Balance actual en Devnet: {balance:.4f} SOL")
        return balance
    except Exception as e:
        print(f"‚ùå Error al obtener el balance: {e}")
        return None

# Funci√≥n para comprar tokens (simulada en Devnet)
def comprar_token(riesgo_sol):
    if TOKEN_ADDRESS == "nombre_token":
        print("‚ùå Error: El token no est√° definido. Por favor, define un TOKEN_ADDRESS v√°lido.")
        return
    try:
        print(f"üõí Simulando compra de {riesgo_sol:.4f} SOL del token {TOKEN_ADDRESS}...")
        txn = Transaction(
            fee_payer=public_key,
            recent_blockhash=client.get_recent_blockhash().value.blockhash
        )
        txn.add(
            transfer(
                TransferParams(
                    from_pubkey=public_key,
                    to_pubkey=PublicKey.from_string("EjemploDireccionDestino"),
                    lamports=int(riesgo_sol * 1e9)
                )
            )
        )
        response = client.send_transaction(txn, keypair, opts={"skip_preflight": True, "preflight_commitment": Confirmed})
        print(f"‚úÖ Compra simulada completada: {response}")
    except Exception as e:
        print(f"‚ùå Error al realizar la compra simulada: {e}")

# Funci√≥n principal del bot
def main():
    precio_solana = obtener_precio_solana()
    if not precio_solana:
        print("‚ùå No se pudo obtener el precio de Solana. Saliendo...")
        return

    balance = obtener_balance(public_key)
    if balance is None:
        return

    riesgo_sol = calcular_riesgo_sol(RIESGO_USDT, precio_solana)
    if riesgo_sol is None:
        return

    calcular_riesgo_porcentual(balance, riesgo_sol)

    # Realizar una √∫nica compra
    comprar_token(riesgo_sol)
    print("‚úÖ Compra √∫nica realizada.")
    
    if CONDICION_SALIDA:
        vender_token(riesgo_sol)
        print("‚úÖ Venta realizada por condici√≥n de salida. Bot detenido.")

if __name__ == '__main__':
    main()
