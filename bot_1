import os
import base64
import time
from dotenv import load_dotenv
from solana.rpc.api import Client
from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair
from solders.transaction import Transaction
from solders.system_program import transfer, TransferParams
from solana.rpc.commitment import Confirmed
import threading

# Cargar variables de entorno
load_dotenv()

# Variables de entorno
PRIVATE_KEY = os.getenv('PRIVATE_KEY')
PUBLIC_KEY = os.getenv('PUBLIC_KEY')
RPC_URL = f"https://devnet.helius-rpc.com/?api-key={os.getenv('HELIUS_API_KEY')}"
TOKEN_ADDRESS = "nombre_token"  # Se define mÃ¡s adelante
RIESGO_USDT = 10  # Monto en USDT definido por el usuario
CONDICION_SALIDA = True  # Activar la condiciÃ³n de salida
UMBRAL_SALIDA = 1.01  # Salir cuando el valor del token aumente un 1%
UMBRAL_BAJA = 0.96  # Salir si el valor del token disminuye un 4%
STOP_MANUAL = False  # Variable para detener manualmente el bot

# Validar claves
if not PRIVATE_KEY:
    raise ValueError("âŒ PRIVATE_KEY no estÃ¡ definida en el archivo .env")
if not PUBLIC_KEY:
    raise ValueError("âŒ PUBLIC_KEY no estÃ¡ definida en el archivo .env")
if not RPC_URL or 'api-key=' not in RPC_URL:
    raise ValueError("âŒ HELIUS_API_KEY no estÃ¡ definida correctamente en el archivo .env")

# Inicializar cliente RPC con Helius en Devnet
try:
    client = Client(RPC_URL)
    print("âœ… Cliente RPC de Helius (Devnet) conectado correctamente.")
except Exception as e:
    print(f"âŒ Error al conectar con RPC de Helius (Devnet): {e}")
    exit()

# Inicializar billetera
try:
    if PRIVATE_KEY:
        keypair = Keypair.from_bytes(base64.b64decode(PRIVATE_KEY))
        public_key = PublicKey.from_string(PUBLIC_KEY)
        print(f"âœ… Wallet conectada: {public_key}")
    else:
        raise ValueError("PRIVATE_KEY no encontrada en el archivo .env")
except Exception as e:
    print(f"âŒ Error al cargar la clave privada: {e}")
    exit()

# Obtener el precio actual de Solana (usando un proveedor de datos externo)
def obtener_precio_solana():
    try:
        import requests
        response = requests.get('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd')
        data = response.json()
        return data['solana']['usd']
    except Exception as e:
        print(f"âŒ Error al obtener el precio de Solana: {e}")
        return None

# Calcular el riesgo en SOL
def calcular_riesgo_sol(riesgo_usdt, precio_solana):
    if precio_solana:
        riesgo_sol = riesgo_usdt / precio_solana
        print(f"ðŸ’µ Riesgo definido: {riesgo_usdt} USDT â‰ˆ {riesgo_sol:.4f} SOL")
        return riesgo_sol
    else:
        print("âŒ No se pudo calcular el riesgo en SOL debido a un error en el precio de Solana.")
        return None

# Calcular el riesgo porcentual respecto al balance
def calcular_riesgo_porcentual(balance, riesgo_sol):
    if balance > 0:
        riesgo_porcentual = (riesgo_sol / balance) * 100
        print(f"ðŸ“Š Riesgo porcentual: {riesgo_porcentual:.2f}% del balance total.")
        return riesgo_porcentual
    else:
        print("âŒ Balance insuficiente para calcular riesgo porcentual.")
        return None

# Obtener el balance de la cuenta
def obtener_balance(public_key):
    try:
        balance_response = client.get_balance(public_key)
        balance = balance_response.value / 1e9  # Convertir de lamports a SOL
        print(f"ðŸ’° Balance actual en Devnet: {balance:.4f} SOL")
        return balance
    except Exception as e:
        print(f"âŒ Error al obtener el balance: {e}")
        return None

# FunciÃ³n para comprar tokens (simulada en Devnet)
def comprar_token(riesgo_sol):
    if TOKEN_ADDRESS == "nombre_token":
        print("âŒ Error: El token no estÃ¡ definido. Por favor, define un TOKEN_ADDRESS vÃ¡lido.")
        return
    try:
        print(f"ðŸ›’ Simulando compra de {riesgo_sol:.4f} SOL del token {TOKEN_ADDRESS}...")
        txn = Transaction(
            fee_payer=public_key,
            recent_blockhash=client.get_recent_blockhash().value.blockhash
        )
        txn.add(
            transfer(
                TransferParams(
                    from_pubkey=public_key,
                    to_pubkey=PublicKey.from_string("EjemploDireccionDestino"),
                    lamports=int(riesgo_sol * 1e9)
                )
            )
        )
        response = client.send_transaction(txn, keypair, opts={"skip_preflight": True, "preflight_commitment": Confirmed})
        print(f"âœ… Compra simulada completada: {response}")
        return obtener_precio_solana()
    except Exception as e:
        print(f"âŒ Error al realizar la compra simulada: {e}")
        return None

# FunciÃ³n principal del bot
def main():
    global STOP_MANUAL
    precio_solana = obtener_precio_solana()
    if not precio_solana:
        print("âŒ No se pudo obtener el precio de Solana. Saliendo...")
        return

    balance = obtener_balance(public_key)
    if balance is None:
        return

    riesgo_sol = calcular_riesgo_sol(RIESGO_USDT, precio_solana)
    if riesgo_sol is None:
        return

    calcular_riesgo_porcentual(balance, riesgo_sol)
    precio_compra = comprar_token(riesgo_sol)
    if precio_compra:
        while CONDICION_SALIDA and not STOP_MANUAL:
            precio_actual = obtener_precio_solana()
            if precio_actual:
                if precio_actual >= precio_compra * UMBRAL_SALIDA:
                    print(f"âœ… CondiciÃ³n de salida cumplida (Subida): Precio actual {precio_actual:.2f} USD")
                    break
                if precio_actual <= precio_compra * UMBRAL_BAJA:
                    print(f"âœ… CondiciÃ³n de salida cumplida (Bajada): Precio actual {precio_actual:.2f} USD")
                    break
            time.sleep(10)
    print("âœ… Bot detenido.")

# Hilo para el botÃ³n de stop manual
def stop_bot():
    global STOP_MANUAL
    input("ðŸ›‘ Presiona Enter para detener el bot manualmente...")
    STOP_MANUAL = True

if __name__ == '__main__':
    threading.Thread(target=stop_bot).start()
    main()
